# 🥚 What I Learned

## 적용한 것들 (적용하려고 노력…한 것들?)

### 1️⃣ MVC 패턴

처음 MVC 패턴을 배우고 적용해봤습니다. 이전에 자바스크립트 파일을 모듈을 나눴을 때는 주체가 누구인가에 집중을 했었습니다. 로또 미션의 경우 현실에서 로또를 사는사람, 파는 사람, 발행하는 사람 등으로 나누어서 역할이 정해져 있습니다. 이것을 토대로 객체를 만들고 현실에 빗대어서 역할을 나누워주었습니다.

이번에 MVC 패턴으로 짜다보니 그것도 중요하지만 비지니스 로직과 UI 로직을 나누는 것이 더 중요한 사항이었습니다. 왜냐하면 UI는 직접적으로 보여주는 역할이고 비지니스 로직은 데이터를 다뤄야하는 역할이기 때문입니다. 즉, 현실세계에서 나눌 수 있는 주체보다 소프트웨어적으로 어떤 구조를 가지고 분리를 해야하는 지에 대해 초점을 맞춰 공부할 수 있었습니다.

MVC 패턴을 적용하면서 가장 고민을 많이한 부분은 `BridgeMap`(다리 게임 출력)을 만드는 것은 View에서 해야하는가 Model(Service)에서 해야하는 가였습니다. 결국 출력을 위한 로직이니 View의 영역인 것 같으면서도 어쨋든 데이터를 가지고 가공을해야하는 거니 Service에 적용되어야하는 것 같기도 했습니다. 제가 내린 결론은 View였습니다. 이유는 간단합니다. View에 비해 Service가 너무 비대합니다. 정말 이런식으로 접근한다면 View에서 해야할 것은 Console 유틸 객체에서 하는 것 외에는 아무것도 할 게 없을 정도일 것입니다. 또한 다른 MVC로 구현된 DOM 처리하는 뷰의 영역을 보아도 결국 출력을 위해 요소를 만들고 가공하는 것은 View의 몫이었던 것이 제 생각에 힘을 실었던 것 같습니다.

### 2️⃣ 테스트하기 좋은 코드

아직도 기억이 생생합니다. 3주차 피드백을 받았을 때 머리를 띵~ 때리는 느낌이었습니다. 테스트하기 힘든 코드를 어떻게 끊어내는지에 대해 나와있었습니다. 처음엔 느낌적인 느낌은 확 왔지만 어쩐지 제대로 이해를 하기 힘들었습니다. 정말 그 짧은 코드를 10번 이상을 보면서 무엇이 문제인지 제대로 알 수 있었습니다.

Random이나 Console 과 같은 객체는 테스트하기 힘듭니다. 왜냐하면 Random의 경우 무작위로 숫자가 생성되기 때문에 mock을 통해 값을 지정해주어야하기 때문입니다. 또한 Console 의 경우 readLine메소드도 사용자가 입력할 값을 mock을 통해 지정해주어야하고, print의 경우는 spyOn을 통해 출력된 값을 관찰해야하기 때문입니다. 때문에 만약 이렇게 테스트하기 어려운 코드들이 의존관계에 따라 불필요하게 다른 객체에까지 확산된다면 이는 재앙일 것입니다. 따라서 이러한 악순환을 최소한으로 하여 다른 객체에게 까지 어려운 테스트 환경을 주게 해주어선 안됩니다.

또한 테스트하기 좋은 코드를 만드는 것은 결국 의존성 문제와도 연결되어 있습니다. 앞서 말씀 드렸듯 저번주차 미션에서는 모듈을 닥치는대로 나누는 데 급급했습니다. 그러다보니 정확한 기준도 없이 서로 계산한 걸 넘겨주는 꼴이 되었습니다. 알고보니 이렇게 의존성이 뒤섞여 있는 코드를 스파게티 코드라고 하는데 그게 제 코드였습니다. 실제로 모듈끼리 서로 데이터를 주고받지 않고 controller을 통해 제어권을 넘겨주는 형식으로 하니 단위 테스트하는 데 훨씬 수월해졌음을 느꼈습니다.

### 3️⃣ 고차함수를 통해 다형성 구현

이 내용에 대해 처음 알게 된 것은 저번주차에 읽었던 코딩의 기술 덕분입니다. 그때 기억하기로는 filter의 콜백함수를 만들 때 배열의 요소를 받는 인자 외에도 필러링할 key와 value값 또한 커링을 통해 인자로 받음으로써 여러 콜백함수를 손쉽게 만들 수 있었습니다.

이번 미션에서도 유효성 검사를 하는 부분 이 세 군데 나옵니다. bridgeSize, movingDirection, gameCommand 입력을 유저로 부터 받을 때 유효한 입력값인지 확인해야 합니다. 여기서 핵심은 세 가지 모두 같은 로직이라는 것입니다. 따라서 세 가지 경우를 카테고리로 나눠서 입력을 받고 이를 다시 input값을 받아 유효성검사하는 함수를 만들었습니다.

```jsx
check(category) {
  if (!this.REGEX_MAP.has(category)) {
    throw new Error(this.ERROR_MESSAGE_MAP.get(category), `(${category})`);
  }

  return (input) => {
    const testSubject = this.eraseWhiteSpace(input);
    const regex = this.REGEX_MAP.get(category);
    if (!regex.test(testSubject)) throw new Error(this.ERROR_MESSAGE_MAP.get(category));
  };
}

checkBridgeSize = this.check('bridgeSize');

checkMoving = this.check('moving');

checkGameCommand = this.check('gameCommand');
```

위의 코드처럼 check 메소드를 하나 만든 다음에 다양한 input값을 확인할 수 있는 함수를 생성할 수 있도록 하여 다형성을 구현했습니다.

### 4️⃣ 10줄 이내라는 의미 찾기

지역 변수를 최대한 줄이려고 노력했습니다. 저번 미션까지는 15줄 제한이 있었습니다. 15줄까지는 필요에 따라 메서드를 분리하는 방법으로 충분히 지킬 수 있는 조건이었습니다. 하지만 10줄 제한은 이야기가 다릅니다. 메서드를 분리하는 것만으로는 지킬 수 없습니다. **만약 10줄 제한만을 위한 메서드 분리라면 그건 정말 불필요한 분리일 것입니다.**

<before>

```jsx
handleMakingBridgeMap(bridgeMap, trial) {
  const [upper, lower] = bridgeMap;
  if (trial.direction === GAME_SIGNATURE.up) {
    upper.push(trail.result);
    lower.push(MAP_SIGNATURE.notSelected);
    return [upper, lower];
  }

  if (trial.direction === GAME_SIGNATURE.up) {
    upper.push(MAP_SIGNATURE.notSelected);
    lower.push(trail.result);
    return [upper, lower];
  }
}
```

예를 들어보겠습니다. 위의 코드는 제가 최종적으로 작성한 출력할 bridgeMap을 만드는 콜백 함수입니다. 정말 애가 타는 코드입니다. 10줄과 15줄 사이에서 어떻게 해야할지를 정말 많이 고민했습니다.

제가 노력하고 생각했던 부분은 크게 두 가지입니다.

1. 우선 최대한 스코프 내에서 지역변수를 선언하는 것을 지양하고 인자로 받을 때 할당한다.
2. 세부적으로 분리할 수 있으면 메서드를 분리하자.

우선 1번에 따라 upper과 lower을 선언한 부분을 인자에서 받을 때 분해할당하는 방식으로 변경했습니다. 문제는 그 아래 입니다. if 안에 있는 statement를 메서드를 분리할까도 생각했습니다.

**하지만, 정말 아무리 10줄 제한을 지키라고 하더라도 이걸 메서드로 분리하는 것은 오히려 코드를 망치는 일이다!** 라는 생각이 강하게 들었습니다. 왜냐하면 이 함수는 bridgeMap을 만드는 콜백 함수이고 만드는 과정이 어렵지 않기 때문에 이 스코프 안에서 해결되어야 한다는 생각이 들었습니다.

진짜 문제는 여기서 부터였습니다. 자바스크립트 코딩의 기술 책에서 보았던 객체의 원본을 사용하지말라는 조언이 떠올랐습니다. 물론 reduce 함수에 사용할 콜백함수이기 때문에 값이 계속 누적되는 과정에서 순회하는 배열일 뿐인데 괜찮지 않을까? 라는 생각을 했습니다. **하지만 여기서는 단순히 배열에 push를 한 다음 추가 작업이 없지만 만약 추가 작업할 코드가 생긴다면? 원본이 훼손되기 때문에 버그의 원인이 됩니다.**

<after>

```jsx
handleMakingBridgeMap([upper, lower], { direction: moving, result: movingResult }) {
  if (moving === GAME_SIGNATURE.up) {
    return new Array([...upper, movingResult], [...lower, MAP_SIGNATURE.notSelected]);
  }

  if (moving === GAME_SIGNATURE.down) {
    return new Array([...upper, MAP_SIGNATURE.notSelected], [...lower, movingResult]);
  }
}
```

그렇다고 포기할 사람이 아닙니다. 우선 bridgeMap인자 뿐만 아니라 trial 역시 객체분해할당을 해주어 함수 내부를 더 분명하게 표현했습니다. 그리고 가장 난제였던 부분은 스프레드 연산자를 사용하여 push를 하였고 가공한 재료들로 새로운 배열을 만들어 반환하는 방식으로 바꾸었습니다.

# 🐥 Review

“배운다”는 것은 지식 습득만으로 이뤄질 수 없습니다. 배운 지식을 활용할 수 있도록 경험하고 단련하는 것에서 정말 “배웠다”라고 말할 수 있게 되는 것 같습니다. 3주차까지 정리해 놓은 배운 내용들은 어쩌면 이번 미션에서 총집라해서 써 먹을 수 있는 자양분이 된 것 같습니다.

가장 재밌었던 부분은 모듈을 나누는 것부터 시작인 것 같습니다. 코딩 테스트 문제만 풀어보다가 클래스 별로 모듈을 나눠보고, 그 다음 주차에서는 최대한 많이 나눠보고, 그리고 이번 주차에서는 특정 패턴에 역할을 분리해봤습니다. 그 전 주차에도 충분히 많이 배웠다고 생각했는데 계속 공부하고 계속 생각할 것들이 나타난 것이 정말 신기했습니다.

그리고 “너 정말 이거 알아?”를 검증하는 주차였던 것 같습니다. 자바스크립트에 많이 익숙해졌다고 생각했는데 막상 코드를 짜고 리팩토링을 하다 보니 배웠던 내용들을 제대로 적용시키지 못한 모습을 봤습니다. 특히 인자로 받은 객체의 경우에 원본을 훼손시키지 말라는 말을 지난 주 코딩의 기술 책을 읽으면서 무수히 많이 봤던 내용이었습니다. 하지만 그걸 안 지키고 Array의 push 메소드를 아주 마음껏 쓰는 모습을 목도할 수 있었습니다.

이 정도면 괜찮지 않을까? 여기에서는 if-else 를 써도 괜찮지 않을까? 로직이 짧으니까 원본을 훼손시켜도 되지 않을까? 여기는 어쩔 수 없으니까 10줄이 넘어가도 되지 않을까? 이런 작은 마음에서 시작해서 많은 생각을 한 마지막 주였습니다. 생각을 하다보니 단순히 “지켜야 할 것”에서 “왜 지키라고 했는지”를 조금씩 이해해갈 수 있었습니다.

# 🍗 What Have To do

이제 정겨웠던 우테코와 작별 인사를 해야합니다. 슬랙과 Discussion에서 정말 많이 배울 수 있었는데 과정이 끝나도 계속 정보를 공유할 수 있었으면 하는 바람이 있습니다. 우선 가장 먼저 해야할 것은 마지막 주차에 대한 피드백일 것입니다. 이제 시간적 압박 없이 마음껏 피어리뷰를 할 수 있을 것 같습니다. 왜냐하면 다음 미션이 없기 때문!

그리고 나서 제 자리로 돌아가려 합니다. 미처 못다한 HTML, CSS 공부부터 차근차근하려고 합니다. 그리고 리액트를 배우면서 바닐라 자바스크립트 구현에서 어려웠던 점들이 어떻게 쉽게 처리할 수 있는지 배우려고 합니다. 혹시 모를 기대와 함께 틈틈히 자바스크립트 구현 코딩테스트 문제도 풀어볼까 합니다.
