# 학습 체크리스트

- [x] jest 적용하기
- [x] 구현!

# 학습 내용

## 1️⃣ jest

### jest

테스팅 프레임워크

### matcher

- toThrow: `expect(() => getUser(-1)).toThrow()` , 반드시 에러를 함수로 한번 감싸주어야 합니다.

### 비동기

- **콜백**: 콜백함수 내부에서 expect()실행합니다. 다만 test 콜백함수 인자로 done을 받고 실행줘야합니다.
- **프로미스**: .`then((res) ⇒ expect().toBe())` , 단 반드시 return 키워드를 사용해야합니다.
- **async:** test 콜백 함수를 async 로 하여 await로 변수에 할당할 수 있습니다. return 과 done 모두 필요하지 않습니다.

### 전후처리하기

배열이나 객체의 요소를 추가, 삭제, 수정하는 과정에서 원본 데이터가 훼손될 수 있습니다. 이럴 경우를 대비해서 테스트 전후에 일정하게 처리할 수 있습니다.

### jest.fn(), jest.spyOn()

- 모킹: 단위 테스트를 작성할 때 코드가 의존하는 부분을 가짜로 대체합니다.
- 실제 데이터를 쓰지 않는 이유
  1. 비동기 테스트의 경우 실행 속도 문제
  2. 네트워크 환경에 영향을 받음
  3. 변경 데이터를 계속 원복시켜줘야함
  4. 특정 기능만 분리해서 테스트하는 것이 Unit Test임
- jest.fn()
  - mockReturnValue()
  - mockResolvedValue() : 비동기 함수의 prosmise가 resolve한 값
  - mockImplementation(()⇒{}) : 직접 구현도 가능
  - 모킹 함수가 몇번 실행되었는지, 어떤 인자를 받고 어떤 값을 반환했는지 기록하는 것을 이용하여 테스트 진행
- jest.spyOn()
  - 해당 함수의 호출 여부와 어떻게 호출되었는지만을 알아내야 할 때가 사용합니다.
  - 예시: `const spyGet = jest.spyOn(axios, "get")` axios객체의 get함수에 스파이를 붙입니다. 해당 메소드가 호출되었는지, 몇번 되었는 지 등 저장합니다.
  - 하지만 단점은 직접 호출되는 값을 가져온 것이기 때문에 외부환경에서 자유로울 수 없다는 단점이 있습니다.
  - 장점은 직접 실행된 결과를 엿볼 수 있다는 것입니다. 우테코 미션에서도 이 spyOn()메소드가 사용된 것은 콘솔로 출력된 값을 확인하는 절차가 필요하기 때문입니다. 이 부분은 jest.fn()을 통해 가짜 개체로 대체할 수 없습니다. 정말 출력된 값을 확인해야합니다. 그래서 spyOn()을 사용한 것입니다.

### 모듈 모킹

- `jest.mcok(”./module”)`
- 모듈에서 import된 객체들을 일일이 jest.fn()할 필요가 없어집니다. 자동으로 모듈 모킹을 해주기 때문입니다.

### 모범사례

1. 테스트 린트 규칙 사용하기
2. DRY 원칙을 지키기
   1. 같은 describe에서 서로 다른 test에 mock을 생성하지 말아야 합니다. describe 스코프에서 딱 한 번 선언해야 합니다.
   2. 필요에 따라 전후처리를 통해 로직을 캡슐화합니다.
3. describe 블록에서 테스트 그룹화하기
4. 단위 테스트는 실패할 이유가 하나만 있어야 합니다.
   1. SOLID 원칙에서 단일 책임 원칙을 따릅니다.
5. 테스트를 독립적으로 유지하기
6. 다양하게 입력되는 매개변수 테스트하기
   1. 입력 범위 테스트를 하여 엣지 케이스를 확인합니다.

[[번역] 프런트엔드 단위 테스트 모범 사례](https://velog.io/@surim014/frontend-unit-testing-best-practices?utm_source=substack&utm_medium=email)

🔗 참고자료

| 제목                            | 링크                                                                                                 |
| ------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 프런트엔드 단위 테스트 모범사례 | https://velog.io/@surim014/frontend-unit-testing-best-practices?utm_source=substack&utm_medium=email |
| jest mock()                     | https://www.daleseo.com/jest-mock-modules/                                                           |

# 회고

## 1️⃣ 배운 점

이전에는 Jest를 공부하면서 mock에 대한 문법만 익히는데 급급했습니다. 그래서 이게 왜 필요한 것인지 몰랐는데 이번에 mock이라는 개념이 왜 테스트에 적용되어야 하는지 알 수 있었습니다. 저번 미션에서 모듈을 분리하는 것을 익히면서 자연스레 너무 많은 모듈끼리 의존하고 있는 것은 아닌지 고민이 있었습니다. 그런 것들이 테스트 코드를 작성하는 것에도 영향을 미친다는 것을 알고 어떻게 의존관계를 효율적으로 적용할 지에 대해도 많이 배웠습니다.

## 2️⃣ 배울 점

내일은 구현에 초점을 맞추려고 합니다. 구현을 진행하면서 간단한 수준의 기능 테스트를 같이 진행할 예정입니다.
